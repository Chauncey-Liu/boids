//#include "Assets/Shaders/cginc/Perlin.cginc"

// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#define GROUP_SIZE 512

/* boids */
struct Boid
{
    float3 position, velocity;
};

Boid ConstructBoid(float3 position, float3 velocity)
{
    Boid boid;
    boid.position = position;
    boid.velocity = velocity;

    return boid;
}

RWStructuredBuffer<Boid> boids;
uint numBoids;

/* Flock behaviour params, same for each boid */
//other boid reactions
float avoidDist;
float avoidSpeed;

//cursor following
bool usingCursorFollow;
float cursorFollowSpeed;

//movement bounds
bool usingBounds;
float boundsSize;
float3 boundsCentre;
float boundsReturnSpeed;

//idle move
bool usingIdleMvmt;
float idleNoiseFrequency;
float idleOffset;
float idleSpeed;

float3 ReactToOtherBoids(uint id)
{
    Boid boid = boids[id];
    float3 pos = boid.position;
    float3 vel = boid.velocity;

    float3 newVel = vel; //new position of boid after applying flocking rules
    
    float3 avoidDir = float3(0, 0, 0);
    float3 centre = float3(0, 0, 0);
    float3 velocityMatch = float3(0, 0, 0);

    uint neighbourCount = 0;
    for (uint i = 0; i < numBoids; i++)
    {
        if (i != id)
        {
            neighbourCount++;

            Boid otherBoid = boids[i];
            if (distance(pos, otherBoid.position) < avoidDist)
            {
                avoidDir += vel - otherBoid.position;
                centre += otherBoid.position - pos;
                velocityMatch += otherBoid.velocity;
            }
        }
    }

    float avg = 1 / neighbourCount;
    centre *= avg;
    velocityMatch *= avg;

    newVel += (avoidDir * avoidSpeed) + centre + velocityMatch;
    return newVel;
}

/*
float3 MoveIdle()
{

}

float3 FollowCursor()
{

}

float3 ReturnToBounds()
{

}
*/

[numthreads(GROUP_SIZE,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    float3 newVel = ReactToOtherBoids(id.x);
    boids[id.x] = ConstructBoid(boids[id.x].position, newVel);
}
